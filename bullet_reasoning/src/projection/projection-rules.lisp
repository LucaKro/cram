;;;
;;; Copyright (c) 2010, Lorenz Moesenlechner <moesenle@in.tum.de>
;;; All rights reserved.
;;; 
;;; Redistribution and use in source and binary forms, with or without
;;; modification, are permitted provided that the following conditions are met:
;;; 
;;;     * Redistributions of source code must retain the above copyright
;;;       notice, this list of conditions and the following disclaimer.
;;;     * Redistributions in binary form must reproduce the above copyright
;;;       notice, this list of conditions and the following disclaimer in the
;;;       documentation and/or other materials provided with the distribution.
;;;     * Neither the name of the Intelligent Autonomous Systems Group/
;;;       Technische Universitaet Muenchen nor the names of its contributors 
;;;       may be used to endorse or promote products derived from this software 
;;;       without specific prior written permission.
;;; 
;;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
;;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;;; POSSIBILITY OF SUCH DAMAGE.
;;;

(in-package :btr)

(defgeneric execute-projection-rule (world rule-name &rest rule-arguments)
  (:documentation "Retunrs the sequence of events that are generated
  by exectuing `rule' in `world'")
  (:method ((world bt-reasoning-world-state) rule-name &rest rule-arguments)
    (apply #'execute-projection-rule
           (restore-world-state world (make-instance 'bt-reasoning-world))
           rule-name rule-arguments)))

(defgeneric timeline-apply-projection-rule (timeline rule-name &rest rule-arguments)
  (:documentation "Executes an rule on `timeline', i.e. advances the
  timeline with the events generated by `rule'")
  (:method ((timeline timeline) (rule-name symbol) &rest rule-arguments)
    (map 'nil (curry #'timeline-advance timeline)
         (apply #'execute-projection-rule (timeline-current-world-state timeline)
                rule-name rule-arguments))
    timeline))

(defmacro def-projection-rule (name world-var args &body body)
  (with-gensyms (name-var events rule-arguments)
    `(defmethod execute-projection-rule ((,world-var bt-reasoning-world) (,name-var (eql ',name))
                                         &rest ,rule-arguments)
       (let ((,events nil))
         (macrolet ((event (event-pat time)
                      `(let* ((new-world (execute-event ,',world-var ,event-pat)))
                         (push (make-instance
                                'event
                                :world-state (get-state new-world)
                                :event ,event-pat
                                :timestamp ,time)
                               ,',events)
                         (setf ,',world-var new-world))))
           (flet ((rule ,args
                    ,@body))
             (map 'nil (lambda (var-name var)
                         (when (typep var 'object)
                           (warn 'simple-warning
                                 :format-control "Variable ~a is of type OBJECT. This will probably lead to bugs since the OBJECT is in the wrong world instance"
                                 :format-arguments (list var-name var))))
                  ',args
                  ,rule-arguments)
             (apply #'rule ,rule-arguments)
             (sort ,events #'< :key #'timestamp)))))))
